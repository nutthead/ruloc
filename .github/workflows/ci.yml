# ============================================================================
# CI Pipeline
# ============================================================================
# CI workflow featuring:
# - Rust build caching via Swatinem/rust-cache
# - Parallel job execution across key platforms
# - Fail-fast quick checks before the full test matrix
# - Tool installation via cargo-binstall with fallbacks
# - Coverage reporting and optional PR comments
# - Merge queue support

name: CI

on:
  pull_request:
    types: [opened, synchronize, reopened]
    paths:
      - 'src/**'
      - 'Cargo.toml'
      - 'Cargo.lock'
      - '.github/workflows/**'
      - '.tarpaulin.toml'
  push:
    branches: [master]
    paths:
      - 'src/**'
      - 'Cargo.toml'
      - 'Cargo.lock'
      - '.github/workflows/**'
      - '.tarpaulin.toml'
  merge_group:
    types: [checks_requested]
  workflow_dispatch:
  schedule:
    - cron: '0 0 * * MON'

# Cancel in-progress runs for the same PR/branch to save CI resources
# Each PR gets its own concurrency group; pushes to branches share a group
concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

# Environment variables shared across all jobs
env:
  RUST_VERSION: "1.90.0"  # Pinned Rust version for consistency
  CARGO_TERM_COLOR: always  # Enable colored output in CI logs
  CARGO_REGISTRIES_CRATES_IO_PROTOCOL: sparse  # Use sparse registry protocol
  RUST_BACKTRACE: short  # Provide backtraces without excessive noise

permissions:
  contents: read
  actions: read

jobs:
  # Fast-fail checks run before the expensive test matrix
  quick-check:
    name: Quick Checks
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          fetch-depth: 0

      - name: Install Rust toolchain
        uses: actions-rust-lang/setup-rust-toolchain@02be93da58aa71fb456aa9c43b301149248829d8 # v1.15.1
        with:
          toolchain: 1.90.0
          components: rustfmt, clippy

      - name: Setup Rust cache
        uses: Swatinem/rust-cache@f13886b937689c021905a6b90929199931d60db1 # v2.8.1
        with:
          cache-on-failure: true
          prefix-key: "v2-rust"
          key: quick-check

      - name: Check formatting
        run: cargo fmt --all -- --check

      - name: Clippy (fail-fast)
        run: cargo clippy --all-targets --all-features -- -D warnings

      - name: Check documentation
        run: cargo doc --no-deps --all-features
        env:
          RUSTDOCFLAGS: "-D warnings"

      - name: Validate changelog format
        run: |
          if [ ! -f "CHANGELOG.md" ]; then
            echo "‚ö†Ô∏è  CHANGELOG.md not found (will be created by release-plz)"
            exit 0
          fi

          if ! grep -q "^# Changelog" CHANGELOG.md; then
            echo "‚ùå Invalid changelog format - missing '# Changelog' header"
            exit 1
          fi

          echo "‚úÖ Changelog format is valid"

  # Security audit runs in parallel with quick-check
  # Continues on error since advisory warnings shouldn't block PRs
  security:
    name: Security Audit
    runs-on: ubuntu-latest
    timeout-minutes: 20
    continue-on-error: true  # Advisory warnings are informational only
    steps:
      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      - name: Install Rust toolchain
        uses: actions-rust-lang/setup-rust-toolchain@02be93da58aa71fb456aa9c43b301149248829d8 # v1.15.1
        with:
          toolchain: 1.90.0

      - name: Install cargo-binstall
        uses: cargo-bins/cargo-binstall@38e8f5e4c386b611d51e8aa997b9a06a3c8eb67a # v1.15.6

      - name: Install and run security audit
        run: |
          cargo binstall --force --no-confirm --locked cargo-audit cargo-deny || {
            cargo install --locked cargo-audit
            cargo install --locked cargo-deny
          }

          for tool in cargo-audit cargo-deny; do
            if ! command -v "$tool" >/dev/null 2>&1; then
              echo "${tool} is missing after installation attempts" >&2
              cargo install --locked "$tool"
            fi
          done

          cargo audit --json | tee audit.json
          cargo deny check advisories

      - name: Upload audit results
        if: always()
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: security-audit
          path: audit.json
          retention-days: 90  # Long-term retention for compliance/security artifacts

  # Unit tests run across multiple platforms
  unit-tests:
    name: Unit Tests ${{ matrix.name }}
    needs: [quick-check]
    timeout-minutes: 30
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            name: Linux
            target: x86_64-unknown-linux-gnu
            test_args: ""

          - os: macos-14
            name: macOS (ARM)
            target: aarch64-apple-darwin
            test_args: ""

          - os: windows-latest
            name: Windows
            target: x86_64-pc-windows-msvc
            test_args: ""

          - os: ubuntu-latest
            name: Linux (musl)
            target: x86_64-unknown-linux-musl
            test_args: ""

    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      - name: Install Rust toolchain
        uses: actions-rust-lang/setup-rust-toolchain@02be93da58aa71fb456aa9c43b301149248829d8 # v1.15.1
        with:
          toolchain: 1.90.0
          target: ${{ matrix.target }}
          components: clippy, rustfmt

      - name: Setup Rust cache
        uses: Swatinem/rust-cache@f13886b937689c021905a6b90929199931d60db1 # v2.8.1
        with:
          cache-on-failure: true
          prefix-key: "v2-rust"
          key: ${{ matrix.target }}-${{ matrix.name }}-unit
          save-if: ${{ github.ref == 'refs/heads/master' }}

      - name: Install musl tools
        if: contains(matrix.target, 'musl')
        run: |
          sudo apt-get update
          sudo apt-get install -y musl-tools

      - name: Run unit tests
        run: cargo test --locked --target ${{ matrix.target }} ${{ matrix.test_args }}

  # Generates code coverage report using tarpaulin
  # Uploads to Codecov and posts PR comment with coverage summary
  coverage:
    name: Code Coverage
    needs: [unit-tests]
    runs-on: ubuntu-latest
    timeout-minutes: 45
    permissions:
      contents: read
      issues: write  # Needed for PR coverage comments via issues.createComment
    steps:
      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      - name: Install Rust toolchain
        uses: actions-rust-lang/setup-rust-toolchain@02be93da58aa71fb456aa9c43b301149248829d8 # v1.15.1
        with:
          toolchain: 1.90.0

      - name: Setup Rust cache
        uses: Swatinem/rust-cache@f13886b937689c021905a6b90929199931d60db1 # v2.8.1
        with:
          cache-on-failure: false
          save-if: false

      - name: Install cargo-binstall
        uses: cargo-bins/cargo-binstall@38e8f5e4c386b611d51e8aa997b9a06a3c8eb67a # v1.15.6

      - name: Install and run tarpaulin
        id: tarpaulin
        run: |
          cargo binstall --force --no-confirm --locked cargo-tarpaulin || cargo install --locked cargo-tarpaulin

          if ! command -v cargo-tarpaulin >/dev/null 2>&1; then
            echo "cargo-tarpaulin binary missing after installation attempts" >&2
            cargo install --locked cargo-tarpaulin
          fi

          # Run tarpaulin - differentiate between test failures and coverage threshold
          set +e  # Don't exit script on error
          cargo tarpaulin --timeout 120 --avoid-cfg-tarpaulin
          EXIT_CODE=$?
          set -e

          # Store exit code for later evaluation
          echo "exit_code=$EXIT_CODE" >> "$GITHUB_OUTPUT"

          if [ $EXIT_CODE -eq 0 ]; then
            echo "‚úÖ Coverage passed (above threshold)"
          elif [ $EXIT_CODE -eq 2 ]; then
            echo "‚ö†Ô∏è  Coverage below threshold - will fail after uploading report"
            echo "Uploading report for analysis..."
          else
            echo "‚ùå Tarpaulin failed (exit code: $EXIT_CODE)"
            echo "This indicates test failures or compilation errors"
            exit $EXIT_CODE  # Fail immediately on real errors
          fi

      - name: Upload coverage to Codecov
        if: always()
        uses: codecov/codecov-action@5a1091511ad55cbe89839c7260b706298ca349f7 # v5.5.1
        with:
          files: target/tarpaulin/cobertura.xml
          flags: unittests
          name: codecov-umbrella
          fail_ci_if_error: false

      - name: Determine if PR comment should be posted
        id: check-pr
        if: always()
        run: |
          SHOULD_COMMENT="false"

          # Check all required conditions
          if [[ "${{ github.event_name }}" == "pull_request" ]] && \
             [[ "${{ github.event.pull_request.head.repo.fork }}" == "false" ]] && \
             [[ -f "target/tarpaulin/cobertura.xml" ]]; then
            SHOULD_COMMENT="true"
          fi

          echo "should_comment=${SHOULD_COMMENT}" >> "$GITHUB_OUTPUT"
          echo "PR comment needed: ${SHOULD_COMMENT}"

      - name: Install coverage parser
        if: always() && steps.check-pr.outputs.should_comment == 'true'
        working-directory: .github/scripts/coverage-comment
        run: npm ci

      - name: Comment coverage on PR
        if: always() && steps.check-pr.outputs.should_comment == 'true'
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8
        with:
          script: |
            const fs = require('fs');
            const { XMLParser } = require('.github/scripts/coverage-comment/node_modules/fast-xml-parser');
            const dedent = require('.github/scripts/coverage-comment/node_modules/dedent');

            const parser = new XMLParser({
              ignoreAttributes: false,
              attributeNamePrefix: ''
            });

            const rawXml = fs.readFileSync('target/tarpaulin/cobertura.xml', 'utf8');
            const parsed = parser.parse(rawXml);
            const coverage = parsed.coverage;

            const linesCovered = Number(coverage['lines-covered'] ?? 0);
            const linesValid = Number(coverage['lines-valid'] ?? 0);
            const lineRate = Number(coverage['line-rate'] ?? 0);
            const lineCoveragePercent = (lineRate * 100).toFixed(2);

            const branchesCovered = Number(coverage['branches-covered'] ?? 0);
            const branchesValid = Number(coverage['branches-valid'] ?? 0);
            const branchRate = Number(coverage['branch-rate'] ?? 0);
            const branchCoveragePercent = branchesValid > 0
              ? `${(branchRate * 100).toFixed(2)}%`
              : 'N/A';

            const complexity = coverage.complexity ?? 'N/A';
            const timestampSeconds = Number(coverage.timestamp);
            const timestamp = Number.isFinite(timestampSeconds)
              ? new Date(timestampSeconds * 1000).toISOString()
              : 'N/A';

            const packages = coverage.packages?.package ?? [];
            const packageList = Array.isArray(packages) ? packages : [packages];
            const classList = packageList.flatMap(pkg => {
              const classes = pkg?.classes?.class ?? [];
              return Array.isArray(classes) ? classes : [classes];
            }).filter(Boolean);

            const fileSummaries = classList.map(cls => {
              const filename = cls?.filename;
              const fileLineRate = Number(cls?.['line-rate'] ?? 0);
              return filename ? {
                filename,
                coverage: Number.isFinite(fileLineRate) ? (fileLineRate * 100).toFixed(1) : 'N/A'
              } : null;
            }).filter(Boolean);

            const filesReported = fileSummaries.length;
            const detailedReport = fileSummaries.length > 0
              ? fileSummaries
                  .sort((a, b) => a.filename.localeCompare(b.filename))
                  .map(({ filename, coverage }) => `${filename}: ${coverage}%`)
                  .join('\n')
              : 'No per-file coverage data available.';

            const coverageTable = `| Metric | Covered | Total | Rate |\n` +
              `|--------|--------:|------:|------:|\n` +
              `| Lines | ${linesCovered} | ${linesValid} | ${lineCoveragePercent}% |\n` +
              `| Branches | ${branchesCovered} | ${branchesValid} | ${branchCoveragePercent} |`;

            const metadataTable = `| Additional Metric | Value |\n` +
              `|-------------------|-------|\n` +
              `| Complexity | ${complexity} |\n` +
              `| Files Reported | ${filesReported} |\n` +
              `| Report Timestamp | ${timestamp} |`;

            const body = dedent`
              ## üìä Coverage Report

              ${coverageTable}

              ${metadataTable}

              <details>
              <summary>View detailed report</summary>

              \`\`\`
              ${detailedReport}
              \`\`\`

              </details>

              ---
              *Generated by cargo-tarpaulin*
            `;

            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body
            });

      - name: Enforce coverage threshold
        if: always() && steps.tarpaulin.outputs.exit_code == '2'
        run: |
          echo "‚ùå Coverage is below the required threshold (80%)"
          echo "Review the coverage report uploaded to Codecov for details"
          exit 1

  # Final status check required by branch protection
  ci-success:
    name: CI Success
    # Use GitHub's native conditional syntax for clearer intent
    # Job runs only if all critical jobs pass and security doesn't fail
    if: |
      always() &&
      needs.quick-check.result == 'success' &&
      needs.unit-tests.result == 'success' &&
      needs.coverage.result == 'success' &&
      (needs.security.result == 'success' || needs.security.result == 'skipped')
    needs: [quick-check, security, unit-tests, coverage]
    runs-on: ubuntu-latest
    timeout-minutes: 5
    permissions:
      contents: read
      checks: write  # Needed for merge queue status checks
    steps:
      - name: Report success
        run: echo "‚úÖ All CI checks passed"

      - name: Set merge queue status
        if: github.event_name == 'merge_group'
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8
        with:
          script: |
            await github.rest.checks.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: 'CI Status',
              head_sha: context.sha,
              status: 'completed',
              conclusion: 'success',
              output: {
                title: 'CI Passed',
                summary: 'All CI checks completed successfully'
              }
            });
